"""\nUnit tests for ExpressionCache.\n\nTests task-level expression caching logic.\nPart of Phase E13 refactoring (January 2026).\n"""\n\nimport unittest\nfrom unittest.mock import Mock, patch\nimport time\n\nfrom core.tasks.cache.expression_cache import ExpressionCache\n\n\nclass TestExpressionCache(unittest.TestCase):\n    """Test ExpressionCache class."""\n    \n    def setUp(self):\n        """Set up test fixtures."""\n        self.cache = ExpressionCache(max_size=50, ttl_seconds=5.0)\n    \n    def test_initialization(self):\n        """Test cache initialization."""\n        self.assertEqual(self.cache._max_size, 50)\n        self.assertEqual(self.cache._ttl, 5.0)\n    \n    def test_get_put_basic(self):\n        """Test basic get/put operations."""\n        expression = \"population > 1000\"\n        compiled_data = {\"compiled\": True, \"ast\": \"...\"}\n        \n        # Put compiled expression\n        self.cache.put(expression, compiled_data)\n        \n        # Get compiled expression\n        cached = self.cache.get(expression)\n        \n        self.assertIsNotNone(cached)\n    \n    def test_get_miss(self):\n        """Test cache miss."""\n        cached = self.cache.get(\"nonexistent expression\")\n        \n        self.assertIsNone(cached)\n    \n    def test_layer_scoped_caching(self):\n        """Test layer-scoped cache keys."""\n        expression = \"status = 'active'\"\n        \n        # Put with layer_id\n        self.cache.put(expression, {\"data\": 1}, layer_id=\"layer_a\")\n        self.cache.put(expression, {\"data\": 2}, layer_id=\"layer_b\")\n        \n        # Get with layer_id - should get different values\n        cached_a = self.cache.get(expression, layer_id=\"layer_a\")\n        cached_b = self.cache.get(expression, layer_id=\"layer_b\")\n        \n        self.assertIsNotNone(cached_a)\n        self.assertIsNotNone(cached_b)\n    \n    def test_clear(self):\n        """Test clearing entire cache."""\n        # Add some entries\n        for i in range(10):\n            self.cache.put(f\"expression_{i}\", {\"index\": i})\n        \n        # Clear cache\n        self.cache.clear()\n        \n        # Should all be cleared\n        cached = self.cache.get(\"expression_0\")\n        self.assertIsNone(cached)\n    \n    def test_get_stats(self):\n        """Test getting cache statistics."""\n        stats = self.cache.get_stats()\n        \n        self.assertIsInstance(stats, dict)\n        self.assertIn('size', stats)\n        self.assertIn('max_size', stats)\n        self.assertIn('hits', stats)\n        self.assertIn('misses', stats)\n        self.assertIn('hit_rate', stats)\n        self.assertIn('ttl_seconds', stats)\n    \n    def test_shared_instance(self):\n        """Test shared singleton instance."""\n        instance1 = ExpressionCache.get_shared_instance()\n        instance2 = ExpressionCache.get_shared_instance()\n        \n        self.assertIs(instance1, instance2)\n    \n    def test_optimize_duplicate_in_clauses(self):\n        """Test IN clause optimization."""\n        # Expression with duplicates\n        expression = '\"id\" IN (1, 2, 3, 2, 1, 4, 3)'\n        \n        with patch('core.tasks.cache.expression_cache.optimize_duplicate_in_clauses') as mock_opt:\n            mock_opt.return_value = '\"id\" IN (1, 2, 3, 4)'\n            \n            optimized = self.cache.optimize_duplicate_in_clauses(expression)\n        \n        mock_opt.assert_called_once_with(expression)\n    \n    def test_build_key_without_layer(self):\n        """Test cache key building without layer ID."""\n        expression = \"test expression\"\n        \n        key = self.cache._build_key(expression)\n        \n        self.assertEqual(key, expression)\n    \n    def test_build_key_with_layer(self):\n        """Test cache key building with layer ID."""\n        expression = \"test expression\"\n        layer_id = \"layer_123\"\n        \n        key = self.cache._build_key(expression, layer_id)\n        \n        self.assertEqual(key, f\"{layer_id}:{expression}\")\n    \n    def test_put_with_custom_ttl(self):\n        """Test putting with custom TTL."""\n        expression = \"temp expression\"\n        data = {\"value\": 42}\n        \n        # Put with custom TTL\n        self.cache.put(expression, data, ttl_seconds=1.0)\n        \n        # Should be in cache\n        cached = self.cache.get(expression)\n        self.assertIsNotNone(cached)\n    \n    def test_invalidate_layer(self):\n        """Test layer invalidation."""\n        layer_id = \"layer_123\"\n        \n        # Add some entries for layer\n        self.cache.put(\"expr1\", {}, layer_id=layer_id)\n        self.cache.put(\"expr2\", {}, layer_id=layer_id)\n        \n        # Invalidate layer\n        count = self.cache.invalidate_layer(layer_id)\n        \n        # Method should complete (even if count is 0 due to TODO)\n        self.assertGreaterEqual(count, 0)\n\n\nif __name__ == '__main__':\n    unittest.main()